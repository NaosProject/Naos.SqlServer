// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ReflectionHelper.Field.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Reflection.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Reflection.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Linq;
    using global::System.Reflection;

    using OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

#if !OBeautifulCodeReflectionSolution
    internal
#else
    public
#endif
    static partial class ReflectionHelper
    {
        /// <summary>
        /// Gets the fields of the specified type,
        /// with various options to control the scope of fields included and optionally order the fields.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
        /// <returns>
        /// The fields in the specified order.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static IReadOnlyList<FieldInfo> GetFieldsFiltered(
            this Type type,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated,
            OrderMembersBy orderMembersBy = OrderMembersBy.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type
                .GetMembersFiltered(memberRelationships, memberOwners, memberAccessModifiers, MemberKinds.Field, memberMutability, memberAttributes, orderMembersBy)
                .Cast<FieldInfo>()
                .ToList();

            return result;
        }

        /// <summary>
        /// Gets the <see cref="FieldInfo"/> for the specified field.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <param name="throwIfNotFound">OPTIONAL value indicating whether to throw if no fields are found.  DEFAULT is to throw..</param>
        /// <returns>
        /// The <see cref="FieldInfo"/> or null if no fields are found and <paramref name="throwIfNotFound"/> is false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints and <paramref name="throwIfNotFound"/> is true.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        public static FieldInfo GetFieldFiltered(
            this Type type,
            string fieldName,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated,
            bool throwIfNotFound = true)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (fieldName == null)
            {
                throw new ArgumentNullException(nameof(fieldName));
            }

            if (string.IsNullOrWhiteSpace(fieldName))
            {
                throw new ArgumentException(Invariant($"{nameof(fieldName)} is white space."));
            }

            var fields = type
                // ReSharper disable once RedundantArgumentDefaultValue
                .GetFieldsFiltered(memberRelationships, memberOwners, memberAccessModifiers, memberMutability, memberAttributes, OrderMembersBy.None)
                .Where(_ => _.Name == fieldName)
                .ToList();

            FieldInfo result;

            if (!fields.Any())
            {
                if (throwIfNotFound)
                {
                    throw new ArgumentException(Invariant($"There is no field named '{fieldName}' on type '{type.ToStringReadable()}', using the specified binding constraints."));
                }
                else
                {
                    result = null;
                }
            }
            else if (fields.Count > 1)
            {
                throw new ArgumentException(Invariant($"There is more than one field named '{fieldName}' on type '{type.ToStringReadable()}', using the specified binding constraints."));
            }
            else
            {
                result = fields.Single();
            }

            return result;
        }

        /// <summary>
        /// Gets the value of a field.
        /// </summary>
        /// <typeparam name="T">The type of the field.</typeparam>
        /// <param name="item">The object.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <returns>
        /// The value of the field.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The field does not have a get method.</exception>
        /// <exception cref="InvalidCastException">The field is not of the specified type.</exception>
        public static T GetFieldValue<T>(
            this object item,
            string fieldName,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var fieldInfo = item.GetType().GetFieldFiltered(fieldName, memberRelationships, memberOwners, memberAccessModifiers, memberMutability, memberAttributes);

            var fieldValue = fieldInfo.GetValue(item);

            var result = fieldValue.CastOrThrowIfTypeMismatch<T>(fieldInfo);

            return result;
        }

        /// <summary>
        /// Gets the value of a field.
        /// </summary>
        /// <param name="item">The object.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <returns>
        /// The value of the field.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The field does not have a get method.</exception>
        public static object GetFieldValue(
            this object item,
            string fieldName,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var fieldInfo = item.GetType().GetFieldFiltered(fieldName, memberRelationships, memberOwners, memberAccessModifiers, memberMutability, memberAttributes);

            var result = fieldInfo.GetValue(item);

            return result;
        }

        /// <summary>
        /// Gets the value of a static field.
        /// </summary>
        /// <typeparam name="T">The type of the field.</typeparam>
        /// <param name="type">The type that contains the field.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <returns>
        /// The value of the field.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The field does not have a get method.</exception>
        /// <exception cref="InvalidCastException">The field is not of the specified type.</exception>
        public static T GetStaticFieldValue<T>(
            this Type type,
            string fieldName,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var fieldInfo = type.GetFieldFiltered(fieldName, memberRelationships, MemberOwners.Static, memberAccessModifiers, memberMutability, memberAttributes);

            var fieldValue = fieldInfo.GetValue(null);

            var result = fieldValue.CastOrThrowIfTypeMismatch<T>(fieldInfo);

            return result;
        }

        /// <summary>
        /// Gets the value of a field on a static type.
        /// </summary>
        /// <param name="type">The type that contains the field.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <returns>
        /// The value of the field.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The field does not have a get method.</exception>
        public static object GetStaticFieldValue(
            this Type type,
            string fieldName,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var fieldInfo = type.GetFieldFiltered(fieldName, memberRelationships, MemberOwners.Static, memberAccessModifiers, memberMutability, memberAttributes);

            var result = fieldInfo.GetValue(null);

            return result;
        }

        /// <summary>
        /// Determines if a type has a field of the specified field name.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <param name="fieldName">The name of the field to check for.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <returns>
        /// true if the type has a field of the specified field name, false if not.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        public static bool HasField(
            this Type type,
            string fieldName,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (fieldName == null)
            {
                throw new ArgumentNullException(nameof(fieldName));
            }

            if (string.IsNullOrWhiteSpace(fieldName))
            {
                throw new ArgumentException(Invariant($"{nameof(fieldName)} is white space."));
            }

            var fields = type
                // ReSharper disable once RedundantArgumentDefaultValue
                .GetFieldsFiltered(memberRelationships, memberOwners, memberAccessModifiers, memberMutability, memberAttributes, OrderMembersBy.None)
                .Where(_ => _.Name == fieldName)
                .ToList();

            var result = fields.Any();

            return result;
        }

        /// <summary>
        /// Determines if the specified field is const (not readonly).
        /// </summary>
        /// <param name="fieldInfo">The field.</param>
        /// <returns>
        /// true if the specified field is const (not readonly), otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        public static bool IsConstField(
            this FieldInfo fieldInfo)
        {
            if (fieldInfo == null)
            {
                throw new ArgumentNullException(nameof(fieldInfo));
            }

            var result = fieldInfo.IsLiteral && (!fieldInfo.IsInitOnly);

            return result;
        }

        /// <summary>
        /// Determines if the specified field is not writable (is readonly or const).
        /// </summary>
        /// <param name="fieldInfo">The field.</param>
        /// <returns>
        /// true if the specified field is not writable, otherwise false.
        /// </returns>
        public static bool IsNotWritableField(
            this FieldInfo fieldInfo)
        {
            if (fieldInfo == null)
            {
                throw new ArgumentNullException(nameof(fieldInfo));
            }

            var result = fieldInfo.IsReadOnlyOrConstField();

            return result;
        }

        /// <summary>
        /// Determines if the specified field is readonly (not const).
        /// </summary>
        /// <param name="fieldInfo">The field.</param>
        /// <returns>
        /// true if the specified field is readonly (not const), otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        public static bool IsReadOnlyField(
            this FieldInfo fieldInfo)
        {
            if (fieldInfo == null)
            {
                throw new ArgumentNullException(nameof(fieldInfo));
            }

            var result = (!fieldInfo.IsLiteral) && fieldInfo.IsInitOnly;

            return result;
        }

        /// <summary>
        /// Determines if the specified field is readonly or const.
        /// </summary>
        /// <param name="fieldInfo">The field.</param>
        /// <returns>
        /// true if the specified field is readonly or const, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        public static bool IsReadOnlyOrConstField(
            this FieldInfo fieldInfo)
        {
            if (fieldInfo == null)
            {
                throw new ArgumentNullException(nameof(fieldInfo));
            }

            var result = fieldInfo.IsReadOnlyField() || fieldInfo.IsConstField();

            return result;
        }

        /// <summary>
        /// Determines if the specified field is writable (not readonly and not const).
        /// </summary>
        /// <param name="fieldInfo">The field.</param>
        /// <returns>
        /// true if the specified field is writable, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="fieldInfo"/> is null.</exception>
        public static bool IsWritableField(
            this FieldInfo fieldInfo)
        {
            if (fieldInfo == null)
            {
                throw new ArgumentNullException(nameof(fieldInfo));
            }

            var result = !fieldInfo.IsReadOnlyOrConstField();

            return result;
        }

        /// <summary>
        /// Sets a field's value.
        /// </summary>
        /// <param name="item">The object.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="value">The value to set the field to.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to the <paramref name="item"/> Type.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="InvalidCastException">Unable to assign null to the field's type.</exception>
        /// <exception cref="InvalidCastException">Unable to assign <paramref name="value"/> type to the field's type.</exception>
        public static void SetFieldValue(
            this object item,
            string fieldName,
            object value,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var fieldInfo = item.GetType().GetFieldFiltered(fieldName, memberRelationships, memberOwners, memberAccessModifiers, memberMutability, memberAttributes);

            value.ThrowIfNotAssignableTo(fieldInfo);

            fieldInfo.SetValue(item, value);
        }

        /// <summary>
        /// Sets a static field's value.
        /// </summary>
        /// <param name="type">The type that contains the field.</param>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="value">The value to set the field to.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="fieldName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="fieldName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one field named <paramref name="fieldName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="InvalidCastException">Unable to assign null to the field's type.</exception>
        /// <exception cref="InvalidCastException">Unable to assign <paramref name="value"/> type to the field's type.</exception>
        public static void SetStaticFieldValue(
            this Type type,
            string fieldName,
            object value,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var fieldInfo = type.GetFieldFiltered(fieldName, memberRelationships, MemberOwners.Static, memberAccessModifiers, memberMutability, memberAttributes);

            value.ThrowIfNotAssignableTo(fieldInfo);

            fieldInfo.SetValue(null, value);
        }

        private static T CastOrThrowIfTypeMismatch<T>(
            this object fieldValue,
            FieldInfo fieldInfo)
        {
            var returnType = typeof(T);

            T result;

            if (fieldValue == null)
            {
                // can't solely rely on the (T) cast - if pi.GetValue returns null, then null can be cast to any reference type.
                var fieldType = fieldInfo.FieldType;

                if (!returnType.IsAssignableFrom(fieldType))
                {
                    throw new InvalidCastException(Invariant($"Unable to cast object of type '{fieldType.ToStringReadable()}' to type '{returnType.ToStringReadable()}'."));
                }

                result = default;
            }
            else
            {
                try
                {
                    result = (T)fieldValue;
                }
                catch (InvalidCastException)
                {
                    throw new InvalidCastException(Invariant($"Unable to cast object of type '{fieldValue.GetType().ToStringReadable()}' to type '{returnType.ToStringReadable()}'."));
                }
            }

            return result;
        }

        private static void ThrowIfNotAssignableTo(
            this object value,
            FieldInfo fieldInfo)
        {
            var fieldType = fieldInfo.FieldType;

            if (value == null)
            {
                if (!fieldType.IsClosedTypeAssignableToNull())
                {
                    throw new InvalidCastException(Invariant($"Unable to assign null value to field of type '{fieldType.ToStringReadable()}'."));
                }
            }
            else
            {
                var valueType = value.GetType();

                if (!fieldType.IsAssignableFrom(valueType))
                {
                    throw new InvalidCastException(Invariant($"Unable to assign value of type '{valueType.ToStringReadable()}' to field of type '{fieldType.ToStringReadable()}'."));
                }
            }
        }
    }
}
