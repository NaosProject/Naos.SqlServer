// --------------------------------------------------------------------------------------------------------------------
// <copyright file="DatabaseHelper.ExecuteNonQuery.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Database.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Database.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Data;
    using global::System.Data.SqlClient;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Linq;
    using global::System.Threading.Tasks;

    using OBeautifulCode.CodeAnalysis.Recipes;

    using static global::System.FormattableString;

#if !OBeautifulCodeDatabaseSolution
    internal
#else
    public
#endif
    static partial class DatabaseHelper
    {
        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        [SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes)]
        public static int ExecuteNonQuery(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var connection = connectionString.OpenSqlConnection(sqlInfoMessageEventHandler))
            {
                var result = connection.ExecuteNonQuery(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, prepareCommand);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static int ExecuteNonQuery(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = command.ExecuteNonQuery();  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static async Task<int> ExecuteNonQueryAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var connection = await connectionString.OpenSqlConnectionAsync(sqlInfoMessageEventHandler))
            {
                var result = await connection.ExecuteNonQueryAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, prepareCommand);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static async Task<int> ExecuteNonQueryAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = await command.ExecuteNonQueryAsync();  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes <paramref name="batchCommandText"/>, and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        [SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes)]
        public static IReadOnlyList<int> ExecuteNonQueryBatch(
            this string connectionString,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (batchCommandText == null)
            {
                throw new ArgumentNullException(nameof(batchCommandText));
            }

            if (string.IsNullOrWhiteSpace(batchCommandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(batchCommandText)}' is white space"));
            }

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"No individual commands found in {nameof(batchCommandText)}."));
            }

            using (var connection = connectionString.OpenSqlConnection(sqlInfoMessageEventHandler))
            {
                var result = connection.ExecuteNonQueryBatch(batchCommandText, commandTimeoutInSeconds);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="batchCommandText"/> against the <paramref name="connection"/> and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static IReadOnlyList<int> ExecuteNonQueryBatch(
            this SqlConnection connection,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlTransaction transaction = null)
        {
            if (batchCommandText == null)
            {
                throw new ArgumentNullException(nameof(batchCommandText));
            }

            if (string.IsNullOrWhiteSpace(batchCommandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(batchCommandText)}' is white space"));
            }

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"no individual commands found in {nameof(batchCommandText)}"));
            }

            var result = new List<int>();

            foreach (var statement in statements)
            {
                var rowsAffected = connection.ExecuteNonQuery(statement, commandTimeoutInSeconds, transaction: transaction);

                result.Add(rowsAffected);
            }

            return result;
        }

        /// <summary>
        /// Opens a connection to the database, executes <paramref name="batchCommandText"/>, and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static async Task<IReadOnlyList<int>> ExecuteNonQueryBatchAsync(
            this string connectionString,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var connection = await connectionString.OpenSqlConnectionAsync(sqlInfoMessageEventHandler))
            {
                var result = await connection.ExecuteNonQueryBatchAsync(batchCommandText, commandTimeoutInSeconds);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="batchCommandText"/> against the <paramref name="connection"/> and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static async Task<IReadOnlyList<int>> ExecuteNonQueryBatchAsync(
            this SqlConnection connection,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlTransaction transaction = null)
        {
            if (batchCommandText == null)
            {
                throw new ArgumentNullException(nameof(batchCommandText));
            }

            if (string.IsNullOrWhiteSpace(batchCommandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(batchCommandText)}' is white space"));
            }

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"no individual commands found in {nameof(batchCommandText)}"));
            }

            var result = new List<int>();

            foreach (var statement in statements)
            {
                var rowsAffected = await connection.ExecuteNonQueryAsync(statement, commandTimeoutInSeconds, transaction: transaction);

                result.Add(rowsAffected);
            }

            return result;
        }
    }
}