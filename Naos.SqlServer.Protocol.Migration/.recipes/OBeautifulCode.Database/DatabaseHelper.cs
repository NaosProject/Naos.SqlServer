// --------------------------------------------------------------------------------------------------------------------
// <copyright file="DatabaseHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Database.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Database.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Data;
    using global::System.Data.SqlClient;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.IO;
    using global::System.Linq;
    using global::System.Threading.Tasks;

    using OBeautifulCode.CodeAnalysis.Recipes;
    using OBeautifulCode.Collection.Recipes;
    using OBeautifulCode.String.Recipes;

    using static global::System.FormattableString;

    /// <summary>
    /// Provides various methods for interacting with a database.
    /// </summary>
#if !OBeautifulCodeDatabaseSolution
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Database.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class DatabaseHelper
    {
        /// <summary>
        /// Opens a SQL Server database connection using a connection string.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// An open SQL Server connection.
        /// </returns>
        [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_DisposableObjectIsMethodReturnObject)]
        public static SqlConnection OpenSqlConnection(
            this string connectionString,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (connectionString == null)
            {
                throw new ArgumentNullException(nameof(connectionString));
            }

            if (string.IsNullOrWhiteSpace(connectionString))
            {
                throw new ArgumentException(Invariant($"'{nameof(connectionString)}' is white space"));
            }

            SqlConnection result = null;

            try
            {
                // an invalid connectionString will throw ArgumentException.
                result = new SqlConnection { ConnectionString = connectionString };

                if (sqlInfoMessageEventHandler != null)
                {
                    result.InfoMessage += sqlInfoMessageEventHandler;
                }

                // InvalidOperationException won't be thrown, even if data source or server aren't specified
                // in the connection string.  as long as the connection string is valid,
                // the only possible exception is SqlException
                result.Open();
            }
            catch (Exception)
            {
                if (result != null)
                {
                    // attempt to gracefully detach the event handler (if applicable) before disposing
                    if (sqlInfoMessageEventHandler != null)
                    {
                        try
                        {
                            result.InfoMessage -= sqlInfoMessageEventHandler;
                        }
                        catch (Exception)
                        {
                        }
                    }

                    result.Dispose();
                }

                throw;
            }

            return result;
        }

        /// <summary>
        /// Opens a SQL Server database connection using a connection string.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// An open SQL Server connection.
        /// </returns>
        public static async Task<SqlConnection> OpenSqlConnectionAsync(
            this string connectionString,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (connectionString == null)
            {
                throw new ArgumentNullException(nameof(connectionString));
            }

            if (string.IsNullOrWhiteSpace(connectionString))
            {
                throw new ArgumentException(Invariant($"'{nameof(connectionString)}' is white space"));
            }

            SqlConnection result = null;

            try
            {
                // an invalid connectionString will throw ArgumentException.
                result = new SqlConnection { ConnectionString = connectionString };

                if (sqlInfoMessageEventHandler != null)
                {
                    result.InfoMessage += sqlInfoMessageEventHandler;
                }

                // InvalidOperationException won't be thrown, even if data source or server aren't specified
                // in the connection string.  as long as the connection string is valid,
                // the only possible exception is SqlException
                await result.OpenAsync();
            }
            catch (Exception)
            {
                if (result != null)
                {
                    // attempt to gracefully detach the event handler (if applicable) before disposing
                    if (sqlInfoMessageEventHandler != null)
                    {
                        try
                        {
                            result.InfoMessage -= sqlInfoMessageEventHandler;
                        }
                        catch (Exception)
                        {
                        }
                    }

                    result.Dispose();
                }

                throw;
            }

            return result;
        }

        /// <summary>
        /// Builds a <see cref="SqlCommand"/> using an existing database connection.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The constructed <see cref="SqlCommand"/>.
        /// </returns>
        [SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "It's convenient to execute a string command and this method does have a parameter for command parameters.")]
        public static SqlCommand BuildSqlCommand(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            // check arguments
            if (connection == null)
            {
                throw new ArgumentNullException(nameof(connection));
            }

            if (connection.State != ConnectionState.Open)
            {
                throw new ArgumentOutOfRangeException(Invariant($"connection is in an invalid state: '{connection.State}'.  Must be Open."), (Exception)null);
            }

            if (commandText == null)
            {
                throw new ArgumentNullException(nameof(commandText));
            }

            if (string.IsNullOrWhiteSpace(commandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(commandText)}' is white space"));
            }

            if (commandTimeoutInSeconds < 0)
            {
                throw new ArgumentOutOfRangeException(Invariant($"'{nameof(commandTimeoutInSeconds)}' < '{0}'"), (Exception)null);
            }

            commandParameters = commandParameters ?? new SqlParameter[0];

            if (commandParameters.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(commandParameters)}' contains an element that is null"));
            }

            // validate transaction
            if (transaction != null)
            {
                if (transaction.Connection == null)
                {
                    throw new ArgumentException(Invariant($"{nameof(transaction)} is invalid; its {nameof(SqlTransaction.Connection)} is null."));
                }

                if (transaction.Connection != connection)
                {
                    throw new ArgumentException(Invariant($"{nameof(transaction)} is using a different {nameof(SqlTransaction.Connection)} than the specified {nameof(connection)}."));
                }
            }

            // create the command.  documentation indicates that this will not throw
            var result = connection.CreateCommand();

            try
            {
                // populate command properties
                result.Connection = connection;
                result.CommandType = commandType;
                result.CommandText = commandText;
                result.CommandTimeout = commandTimeoutInSeconds;

                if (transaction != null)
                {
                    result.Transaction = transaction;
                }

                foreach (var parameter in commandParameters)
                {
                    result.Parameters.Add(parameter);
                }

                if (prepareCommand)
                {
                    result.Prepare();
                }

                return result;
            }
            catch (Exception)
            {
                result.Dispose();

                throw;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>, and builds an <see cref="SqlDataReader"/>.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <remarks>
        /// If an expected parameter type does not match an actual parameter value's type, ExecuteReader() does not throw <see cref="SqlException"/>.
        /// Instead, a reader with no rows is returned.  Any attempt to Read() will throw an exception.
        /// </remarks>
        /// <returns>
        /// A constructed <see cref="SqlDataReader"/>.
        /// </returns>
        [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = ObcSuppressBecause.CA2000_DisposeObjectsBeforeLosingScope_MethodCreatesDisposableObjectButItCannotBeDisposedBecauseReturnObjectRequiresDisposableObjectToBeFullyIntact)]
        public static SqlDataReader ExecuteReader(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (!commandBehavior.HasFlag(CommandBehavior.CloseConnection))
            {
                throw new ArgumentException(Invariant($"{nameof(commandBehavior)} does not set the flag {CommandBehavior.CloseConnection}.  This will result in an open connection with the caller having no means of closing it."));
            }

            var connection = OpenSqlConnection(connectionString, sqlInfoMessageEventHandler);

            var result = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, commandBehavior, prepareCommand);

            return result;
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and builds an <see cref="SqlDataReader"/>.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <remarks>
        /// If an expected parameter type does not match an actual parameter value's type, ExecuteReader() does not throw <see cref="SqlException"/>.
        /// Instead, a reader with no rows is returned.  Any attempt to Read() will throw an exception.
        /// </remarks>
        /// <returns>
        /// A constructed <see cref="SqlDataReader"/>.
        /// </returns>
        public static SqlDataReader ExecuteReader(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = command.ExecuteReader(commandBehavior);  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>, and builds an <see cref="SqlDataReader"/>.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <remarks>
        /// If an expected parameter type does not match an actual parameter value's type, ExecuteReader() does not throw <see cref="SqlException"/>.
        /// Instead, a reader with no rows is returned.  Any attempt to Read() will throw an exception.
        /// </remarks>
        /// <returns>
        /// A constructed <see cref="SqlDataReader"/>.
        /// </returns>
        public static async Task<SqlDataReader> ExecuteReaderAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (!commandBehavior.HasFlag(CommandBehavior.CloseConnection))
            {
                throw new ArgumentException(Invariant($"{nameof(commandBehavior)} does not set the flag {CommandBehavior.CloseConnection}.  This will result in an open connection with the caller having no means of closing it."));
            }

            var connection = await OpenSqlConnectionAsync(connectionString, sqlInfoMessageEventHandler);

            var result = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, commandBehavior, prepareCommand);

            return result;
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and builds an <see cref="SqlDataReader"/>.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <remarks>
        /// If an expected parameter type does not match an actual parameter value's type, ExecuteReader() does not throw <see cref="SqlException"/>.
        /// Instead, a reader with no rows is returned.  Any attempt to Read() will throw an exception.
        /// </remarks>
        /// <returns>
        /// A constructed <see cref="SqlDataReader"/>.
        /// </returns>
        public static async Task<SqlDataReader> ExecuteReaderAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = await command.ExecuteReaderAsync(commandBehavior);  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        [SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes)]
        public static int ExecuteNonQuery(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var connection = connectionString.OpenSqlConnection(sqlInfoMessageEventHandler))
            {
                var result = connection.ExecuteNonQuery(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, prepareCommand);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static int ExecuteNonQuery(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = command.ExecuteNonQuery();  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static async Task<int> ExecuteNonQueryAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var connection = await connectionString.OpenSqlConnectionAsync(sqlInfoMessageEventHandler))
            {
                var result = await connection.ExecuteNonQueryAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, prepareCommand);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static async Task<int> ExecuteNonQueryAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = await command.ExecuteNonQueryAsync();  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes <paramref name="batchCommandText"/>, and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        [SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes)]
        public static IReadOnlyList<int> ExecuteNonQueryBatch(
            this string connectionString,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (batchCommandText == null)
            {
                throw new ArgumentNullException(nameof(batchCommandText));
            }

            if (string.IsNullOrWhiteSpace(batchCommandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(batchCommandText)}' is white space"));
            }

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"No individual commands found in {nameof(batchCommandText)}."));
            }

            using (var connection = connectionString.OpenSqlConnection(sqlInfoMessageEventHandler))
            {
                var result = connection.ExecuteNonQueryBatch(batchCommandText, commandTimeoutInSeconds);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="batchCommandText"/> against the <paramref name="connection"/> and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static IReadOnlyList<int> ExecuteNonQueryBatch(
            this SqlConnection connection,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlTransaction transaction = null)
        {
            if (batchCommandText == null)
            {
                throw new ArgumentNullException(nameof(batchCommandText));
            }

            if (string.IsNullOrWhiteSpace(batchCommandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(batchCommandText)}' is white space"));
            }

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"no individual commands found in {nameof(batchCommandText)}"));
            }

            var result = new List<int>();

            foreach (var statement in statements)
            {
                var rowsAffected = connection.ExecuteNonQuery(statement, commandTimeoutInSeconds, transaction: transaction);

                result.Add(rowsAffected);
            }

            return result;
        }

        /// <summary>
        /// Opens a connection to the database, executes <paramref name="batchCommandText"/>, and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static async Task<IReadOnlyList<int>> ExecuteNonQueryBatchAsync(
            this string connectionString,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var connection = await connectionString.OpenSqlConnectionAsync(sqlInfoMessageEventHandler))
            {
                var result = await connection.ExecuteNonQueryBatchAsync(batchCommandText, commandTimeoutInSeconds);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="batchCommandText"/> against the <paramref name="connection"/> and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static async Task<IReadOnlyList<int>> ExecuteNonQueryBatchAsync(
            this SqlConnection connection,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlTransaction transaction = null)
        {
            if (batchCommandText == null)
            {
                throw new ArgumentNullException(nameof(batchCommandText));
            }

            if (string.IsNullOrWhiteSpace(batchCommandText))
            {
                throw new ArgumentException(Invariant($"'{nameof(batchCommandText)}' is white space"));
            }

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"no individual commands found in {nameof(batchCommandText)}"));
            }

            var result = new List<int>();

            foreach (var statement in statements)
            {
                var rowsAffected = await connection.ExecuteNonQueryAsync(statement, commandTimeoutInSeconds, transaction: transaction);

                result.Add(rowsAffected);
            }

            return result;
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>,
        /// and determines if reading from the <see cref="SqlDataReader"/> results in at least one row of data.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// true if executing the command results in at least one row of data; otherwise false.
        /// </returns>
        [SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes)]
        public static bool HasAtLeastOneRowWhenReading(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = reader.Read();

                reader.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/>
        /// and determines if reading from the <see cref="SqlDataReader"/> results in at least one row of data.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// true if executing the command results in at least one row of data; otherwise false.
        /// </returns>
        [SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = ObcSuppressBecause.CA2202_DoNotDisposeObjectsMultipleTimes_AnalyzerIsIncorrectlyFlaggingObjectAsBeingDisposedMultipleTimes)]
        public static bool HasAtLeastOneRowWhenReading(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.Read();

                reader.Close();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>,
        /// and determines if reading from the <see cref="SqlDataReader"/> results in at least one row of data.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// true if executing the command results in at least one row of data; otherwise false.
        /// </returns>
        public static async Task<bool> HasAtLeastOneRowWhenReadingAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = await reader.ReadAsync();

                reader.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/>
        /// and determines if reading from the <see cref="SqlDataReader"/> results in at least one row of data.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// true if executing the command results in at least one row of data; otherwise false.
        /// </returns>
        public static async Task<bool> HasAtLeastOneRowWhenReadingAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = await reader.ReadAsync();

                reader.Close();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns all rows.
        /// Throws if there are multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// A list with the row values, in the order the rows were returned.
        /// Each row is represented as a dictionary where the keys are column names (case insensitive) and values are the values of the row returned by the query.
        /// </returns>
        public static IReadOnlyList<IReadOnlyDictionary<string, object>> ReadAllRows(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = reader.ReadAllRowsInternal();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns all rows.
        /// Throws if there are multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// A list with the row values, in the order the rows were returned.
        /// Each row is represented as a dictionary where the keys are column names (case insensitive) and values are the values of the row returned by the query.
        /// </returns>
        public static IReadOnlyList<IReadOnlyDictionary<string, object>> ReadAllRows(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadAllRowsInternal();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns all rows.
        /// Throws if there are multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// A list with the row values, in the order the rows were returned.
        /// Each row is represented as a dictionary where the keys are column names (case insensitive) and values are the values of the row returned by the query.
        /// </returns>
        public static async Task<IReadOnlyList<IReadOnlyDictionary<string, object>>> ReadAllRowsAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = await reader.ReadAllRowsInternalAsync();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns all rows.
        /// Throws if there are multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// A list with the row values, in the order the rows were returned.
        /// Each row is represented as a dictionary where the keys are column names (case insensitive) and values are the values of the row returned by the query.
        /// </returns>
        public static async Task<IReadOnlyList<IReadOnlyDictionary<string, object>>> ReadAllRowsAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = await reader.ReadAllRowsInternalAsync();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single column of values.
        /// Throws if the query results in 0 or multiple columns.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The results of the query in the order their were returned from the database.
        /// </returns>
        public static IReadOnlyList<object> ReadSingleColumn(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = reader.ReadSingleColumnInternal();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single column of values.
        /// Throws if the query results in 0 or multiple columns.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The results of the query in the order their were returned from the database.
        /// </returns>
        public static IReadOnlyList<object> ReadSingleColumn(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleColumnInternal();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single column of values.
        /// Throws if the query results in 0 or multiple columns.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The results of the query in the order their were returned from the database.
        /// </returns>
        public static async Task<IReadOnlyList<object>> ReadSingleColumnAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = await reader.ReadSingleColumnInternalAsync();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single column of values.
        /// Throws if the query results in 0 or multiple columns.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The results of the query in the order their were returned from the database.
        /// </returns>
        public static async Task<IReadOnlyList<object>> ReadSingleColumnAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = await reader.ReadSingleColumnInternalAsync();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns the resulting value.
        /// Throws if there are no rows, multiple rows, no columns, or multiple columns.
        /// This is a more restrictive version of <see cref="SqlCommand.ExecuteScalar"/>.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The resulting value.
        /// </returns>
        public static object ReadSingleValue(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = reader.ReadSingleValueInternal();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the resulting value.
        /// Throws if there are no rows, multiple rows, no columns, or multiple columns.
        /// This is a more restrictive version of <see cref="SqlCommand.ExecuteScalar"/>.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The resulting value.
        /// </returns>
        public static object ReadSingleValue(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleValueInternal();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns the resulting value.
        /// Throws if there are no rows, multiple rows, no columns, or multiple columns.
        /// This is a more restrictive version of <see cref="SqlCommand.ExecuteScalar"/>.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// The resulting value.
        /// </returns>
        public static async Task<object> ReadSingleValueAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = await reader.ReadSingleValueInternalAsync();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the resulting value.
        /// Throws if there are no rows, multiple rows, no columns, or multiple columns.
        /// This is a more restrictive version of <see cref="SqlCommand.ExecuteScalar"/>.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The resulting value.
        /// </returns>
        public static async Task<object> ReadSingleValueAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = await reader.ReadSingleValueInternalAsync();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single row of values.
        /// Throws if there are no rows, multiple rows, or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// A dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static IReadOnlyDictionary<string, object> ReadSingleRow(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = reader.ReadSingleRowInternal(throwIfNoRows: true);

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single row of values.
        /// Throws if there are multiple rows or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// null if there are no rows, otherwise a dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static IReadOnlyDictionary<string, object> ReadSingleRowOrDefault(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = reader.ReadSingleRowInternal(throwIfNoRows: false);

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single row of values.
        /// Throws if there are no rows, multiple rows, or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// A dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static IReadOnlyDictionary<string, object> ReadSingleRow(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleRowInternal(throwIfNoRows: true);

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single row of values.
        /// Throws if there are multiple rows or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// null if there are no rows, otherwise a dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static IReadOnlyDictionary<string, object> ReadSingleRowOrDefault(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleRowInternal(throwIfNoRows: false);

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single row of values.
        /// Throws if there are no rows, multiple rows, or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// A dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static async Task<IReadOnlyDictionary<string, object>> ReadSingleRowAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = await reader.ReadSingleRowInternalAsync(throwIfNoRows: true);

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single row of values.
        /// Throws if there are multiple rows or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// null if there are no rows, otherwise a dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static async Task<IReadOnlyDictionary<string, object>> ReadSingleRowOrDefaultAsync(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
            {
                var result = await reader.ReadSingleRowInternalAsync(throwIfNoRows: false);

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single row of values.
        /// Throws if there are no rows, multiple rows, or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// A dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static async Task<IReadOnlyDictionary<string, object>> ReadSingleRowAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = await reader.ReadSingleRowInternalAsync(throwIfNoRows: true);

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single row of values.
        /// Throws if there are multiple rows or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// null if there are no rows, otherwise a dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static async Task<IReadOnlyDictionary<string, object>> ReadSingleRowOrDefaultAsync(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = await connection.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = await reader.ReadSingleRowInternalAsync(throwIfNoRows: false);

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>, and writes the results to a CSV file.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="outputFilePath">Path to file where CSV data should be written.</param>
        /// <param name="includeColumnNames">Indicates whether the first row should be populated with column names.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        public static void WriteToCsv(
            this string connectionString,
            string commandText,
            string outputFilePath,
            bool includeColumnNames = true,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (outputFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputFilePath)}' is white space"));
            }

            using (var writer = new StreamWriter(outputFilePath))
            {
                using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
                {
                    reader.WriteToCsv(writer, includeColumnNames);
                }
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>, and writes the results to a CSV file.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="outputFilePath">Path to file where CSV data should be written.</param>
        /// <param name="includeColumnNames">Indicates whether the first row should be populated with column names.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <param name="sqlInfoMessageEventHandler">OPTIONAL method that will handle the <see cref="SqlConnection.InfoMessage"/> event.</param>
        /// <returns>
        /// A task.
        /// </returns>
        public static async Task WriteToCsvAsync(
            this string connectionString,
            string commandText,
            string outputFilePath,
            bool includeColumnNames = true,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false,
            SqlInfoMessageEventHandler sqlInfoMessageEventHandler = null)
        {
            if (outputFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputFilePath)}' is white space"));
            }

            using (var writer = new StreamWriter(outputFilePath))
            {
                using (var reader = await connectionString.ExecuteReaderAsync(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand, sqlInfoMessageEventHandler))
                {
                    await reader.WriteToCsvAsync(writer, includeColumnNames);
                }
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and writes the results to a CSV file.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="outputFilePath">Path to file where CSV data should be written.</param>
        /// <param name="includeColumnNames">Indicates whether the first row should be populated with column names.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        public static void WriteToCsv(
            this SqlConnection connection,
            string commandText,
            string outputFilePath,
            bool includeColumnNames = true,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            if (outputFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputFilePath)}' is white space"));
            }

            using (var writer = new StreamWriter(outputFilePath))
            {
                using (var reader = ExecuteReader(connection, commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
                {
                    reader.WriteToCsv(writer, includeColumnNames);
                }
            }
        }

        /// <summary>
        /// Rollback a transaction with the proper error handling.
        /// </summary>
        /// <param name="transaction">The transaction to rollback.</param>
        public static void RollbackTransaction(
            this SqlTransaction transaction)
        {
            if (transaction == null)
            {
                throw new ArgumentNullException(nameof(transaction));
            }

            if (transaction.Connection == null)
            {
                // try to detect invalid transaction before calling transaction.Rollback()
                throw new InvalidOperationException("Could not roll back transaction " + transaction + " because the the transaction has already been committed or rolled back -or- the connection is broken.");
            }

            try
            {
                transaction.Rollback();
            }
            catch (InvalidOperationException)
            {
                // the transaction has already been committed or rolled back -or- the connection is broken.
                throw;
            }
            catch (Exception rollbackException)
            {
                throw new InvalidOperationException("Failed to rollback transaction.", rollbackException);
            }
        }

        /// <summary>
        /// Returns the bit representation of a boolean.
        /// </summary>
        /// <param name="value">The boolean to evaluate.</param>
        /// <returns>
        /// "1" if boolean is true, "0" if boolean is false.
        /// </returns>
        public static string ToBit(
            this bool value)
        {
            return value ? "1" : "0";
        }

        private static IReadOnlyList<object> ReadSingleColumnInternal(
            this SqlDataReader reader)
        {
            try
            {
                var result = new List<object>();

                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("Query results in no columns.");
                }

                if (reader.FieldCount != 1)
                {
                    throw new InvalidOperationException("Query results in more than one column.");
                }

                while (reader.Read())
                {
                    result.Add(reader.IsDBNull(0) ? null : reader[0]);
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static async Task<IReadOnlyList<object>> ReadSingleColumnInternalAsync(
            this SqlDataReader reader)
        {
            try
            {
                var result = new List<object>();

                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("Query results in no columns.");
                }

                if (reader.FieldCount != 1)
                {
                    throw new InvalidOperationException("Query results in more than one column.");
                }

                while (await reader.ReadAsync())
                {
                    result.Add(reader.IsDBNull(0) ? null : reader[0]);
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static object ReadSingleValueInternal(
            this SqlDataReader reader)
        {
            try
            {
                if (!reader.Read())
                {
                    throw new InvalidOperationException("Query results in no rows.");
                }

                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("Query results in no columns.");
                }

                if (reader.FieldCount != 1)
                {
                    throw new InvalidOperationException("Query results in more than one column.");
                }

                object result = null;

                if (!reader.IsDBNull(0))
                {
                    result = reader[0];
                }

                if (reader.Read())
                {
                    throw new InvalidOperationException("Query results in more than one row.");
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static async Task<object> ReadSingleValueInternalAsync(
            this SqlDataReader reader)
        {
            try
            {
                if (!(await reader.ReadAsync()))
                {
                    throw new InvalidOperationException("Query results in no rows.");
                }

                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("Query results in no columns.");
                }

                if (reader.FieldCount != 1)
                {
                    throw new InvalidOperationException("Query results in more than one column.");
                }

                object result = null;

                if (!reader.IsDBNull(0))
                {
                    result = reader[0];
                }

                if (await reader.ReadAsync())
                {
                    throw new InvalidOperationException("Query results in more than one row.");
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static IReadOnlyList<IReadOnlyDictionary<string, object>> ReadAllRowsInternal(
            this SqlDataReader reader)
        {
            var result = new List<IReadOnlyDictionary<string, object>>();

            try
            {
                while (reader.Read())
                {
                    var row = reader.ReadRowInternal();

                    result.Add(row);
                }
            }
            finally
            {
                reader.Close();
            }

            return result;
        }

        private static async Task<IReadOnlyList<IReadOnlyDictionary<string, object>>> ReadAllRowsInternalAsync(
            this SqlDataReader reader)
        {
            var result = new List<IReadOnlyDictionary<string, object>>();

            try
            {
                while (await reader.ReadAsync())
                {
                    var row = reader.ReadRowInternal();

                    result.Add(row);
                }
            }
            finally
            {
                reader.Close();
            }

            return result;
        }

        private static IReadOnlyDictionary<string, object> ReadSingleRowInternal(
            this SqlDataReader reader,
            bool throwIfNoRows)
        {
            try
            {
                if (!reader.Read())
                {
                    if (throwIfNoRows)
                    {
                        throw new InvalidOperationException("Query results in no rows.");
                    }

                    return null;
                }

                var result = reader.ReadRowInternal();

                if (reader.Read())
                {
                    throw new InvalidOperationException("Query results in more than one row.");
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static async Task<IReadOnlyDictionary<string, object>> ReadSingleRowInternalAsync(
            this SqlDataReader reader,
            bool throwIfNoRows)
        {
            try
            {
                if (!(await reader.ReadAsync()))
                {
                    if (throwIfNoRows)
                    {
                        throw new InvalidOperationException("Query results in no rows.");
                    }

                    return null;
                }

                var result = reader.ReadRowInternal();

                if (await reader.ReadAsync())
                {
                    throw new InvalidOperationException("Query results in more than one row.");
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static IReadOnlyDictionary<string, object> ReadRowInternal(
            this SqlDataReader reader)
        {
            var result = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

            for (var x = 0; x < reader.FieldCount; x++)
            {
                var fieldName = reader.GetName(x);

                if (result.ContainsKey(fieldName))
                {
                    throw new InvalidOperationException(Invariant($"Query results in two columns with the same name: {fieldName}."));
                }

                result.Add(fieldName, reader.IsDBNull(x) ? null : reader[x]);
            }

            return result;
        }

        private static void WriteToCsv(
            this SqlDataReader reader,
            StreamWriter writer,
            bool includeColumnNames)
        {
            try
            {
                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("A result set wasn't found when executing the command.  Command is a non-query.");
                }

                // write headers
                if (includeColumnNames)
                {
                    var headers = new List<string>();

                    for (var x = 0; x < reader.FieldCount; x++)
                    {
                        headers.Add(reader.GetName(x));
                    }

                    writer.Write(headers.ToCsv());
                }

                // write content
                while (reader.Read())
                {
                    var rowValues = new List<string>();

                    for (var x = 0; x < reader.FieldCount; x++)
                    {
                        if (reader.IsDBNull(x))
                        {
                            rowValues.Add(null);
                        }
                        else
                        {
                            var value = reader.GetValue(x);

                            // strings, chars, and char arrays need to be made CSV-safe.
                            // other data types are guaranteed to never violate CSV-safety rules.
                            if (value is string stringValue)
                            {
                                rowValues.Add(stringValue.ToCsvSafe());
                            }
                            else if (value is char)
                            {
                                rowValues.Add(value.ToString().ToCsvSafe());
                            }
                            else if (value is char[] charArrayValue)
                            {
                                rowValues.Add(charArrayValue.Select(_ => _.ToString(CultureInfo.InvariantCulture)).ToDelimitedString(string.Empty).ToCsvSafe());
                            }
                            else if (value is DateTime valueAsDate)
                            {
                                // DateTime.ToString() will truncate time.
                                var dateAsString = string.Empty;
                                if (valueAsDate.Kind == DateTimeKind.Unspecified)
                                {
                                    // ReSharper disable once StringLiteralTypo
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffff", CultureInfo.InvariantCulture);
                                }
                                else if (valueAsDate.Kind == DateTimeKind.Local)
                                {
                                    // ReSharper disable once StringLiteralTypo
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffffzzz", CultureInfo.InvariantCulture);
                                }
                                else if (valueAsDate.Kind == DateTimeKind.Utc)
                                {
                                    // ReSharper disable once StringLiteralTypo
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffffZ", CultureInfo.InvariantCulture);
                                }

                                rowValues.Add(dateAsString);
                            }
                            else
                            {
                                rowValues.Add(value.ToString());
                            }
                        }
                    }

                    writer.WriteLine();

                    // since we already treated strings for CSV-safety, use ToDelimitedString() instead of ToCsv()
                    writer.Write(rowValues.ToDelimitedString(","));
                }
            }
            finally
            {
                reader.Close();
            }
        }

        private static async Task WriteToCsvAsync(
            this SqlDataReader reader,
            StreamWriter writer,
            bool includeColumnNames)
        {
            try
            {
                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("A result set wasn't found when executing the command.  Command is a non-query.");
                }

                // write headers
                if (includeColumnNames)
                {
                    var headers = new List<string>();

                    for (var x = 0; x < reader.FieldCount; x++)
                    {
                        headers.Add(reader.GetName(x));
                    }

                    await writer.WriteAsync(headers.ToCsv());
                }

                // write content
                while (await reader.ReadAsync())
                {
                    var rowValues = new List<string>();

                    for (var x = 0; x < reader.FieldCount; x++)
                    {
                        if (reader.IsDBNull(x))
                        {
                            rowValues.Add(null);
                        }
                        else
                        {
                            var value = reader.GetValue(x);

                            // strings, chars, and char arrays need to be made CSV-safe.
                            // other data types are guaranteed to never violate CSV-safety rules.
                            if (value is string stringValue)
                            {
                                rowValues.Add(stringValue.ToCsvSafe());
                            }
                            else if (value is char)
                            {
                                rowValues.Add(value.ToString().ToCsvSafe());
                            }
                            else if (value is char[] charArrayValue)
                            {
                                rowValues.Add(charArrayValue.Select(_ => _.ToString(CultureInfo.InvariantCulture)).ToDelimitedString(string.Empty).ToCsvSafe());
                            }
                            else if (value is DateTime valueAsDate)
                            {
                                // DateTime.ToString() will truncate time.
                                var dateAsString = string.Empty;
                                if (valueAsDate.Kind == DateTimeKind.Unspecified)
                                {
                                    // ReSharper disable once StringLiteralTypo
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffff", CultureInfo.InvariantCulture);
                                }
                                else if (valueAsDate.Kind == DateTimeKind.Local)
                                {
                                    // ReSharper disable once StringLiteralTypo
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffffzzz", CultureInfo.InvariantCulture);
                                }
                                else if (valueAsDate.Kind == DateTimeKind.Utc)
                                {
                                    // ReSharper disable once StringLiteralTypo
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffffZ", CultureInfo.InvariantCulture);
                                }

                                rowValues.Add(dateAsString);
                            }
                            else
                            {
                                rowValues.Add(value.ToString());
                            }
                        }
                    }

                    await writer.WriteLineAsync();

                    // since we already treated strings for CSV-safety, use ToDelimitedString() instead of ToCsv()
                    await writer.WriteAsync(rowValues.ToDelimitedString(","));
                }
            }
            finally
            {
                reader.Close();
            }
        }
    }
}