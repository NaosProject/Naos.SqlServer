// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ReflectionHelper.MemberInfo.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Reflection.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Reflection.Recipes
{
    using System.Diagnostics.CodeAnalysis;

    using global::System;
    using global::System.Collections.Generic;
    using global::System.Linq;
    using global::System.Reflection;
    using global::System.Runtime.CompilerServices;

    using OBeautifulCode.CodeAnalysis.Recipes;
    using OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

#if !OBeautifulCodeReflectionSolution
    internal
#else
    public
#endif
    static partial class ReflectionHelper
    {
        /// <summary>
        /// Gets the members (fields, properties, constructors, methods, and events) of the specified type,
        /// with various options to control the scope of members included and optionally order the members.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberKinds">OPTIONAL value that scopes the search for members based on the kind of member.  DEFAULT is to include all kinds of members.</param>
        /// <param name="memberMutability">OPTIONAL value that scopes the search for members based on mutability.  DEFAULT is to include members where mutability is not applicable and where applicable, include members with any kind of mutability.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members that are not compiler generated.</param>
        /// <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
        /// <returns>
        /// The members in the specified order.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static IReadOnlyList<MemberInfo> GetMembersFiltered(
            this Type type,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberKinds memberKinds = MemberKinds.All,
            MemberMutability memberMutability = MemberMutability.All,
            MemberAttributes memberAttributes = MemberAttributes.NotCompilerGenerated,
            OrderMembersBy orderMembersBy = OrderMembersBy.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type
                .GetMembersHavingRelationshipsAndOwners(memberRelationships, memberOwners)
                .FilterMembersHavingKinds(memberKinds)
                .FilterMembersHavingAccessModifiers(memberAccessModifiers)
                .FilterMembersHavingMutability(memberMutability)
                .FilterMembersHavingAttributes(memberAttributes)
                .OrderMembers(type, orderMembersBy);

            return result;
        }

        /// <summary>
        /// Determines if the specified member is compiler-generated.
        /// </summary>
        /// <param name="memberInfo">The member info.</param>
        /// <returns>
        /// True if the member is compiler-generated, otherwise false.
        /// </returns>
        public static bool IsCompilerGenerated(
            this MemberInfo memberInfo)
        {
            if (memberInfo == null)
            {
                throw new ArgumentNullException(nameof(memberInfo));
            }

            var result = memberInfo.CustomAttributes.Select(s => s.AttributeType).Contains(typeof(CompilerGeneratedAttribute));

            return result;
        }

        /// <summary>
        /// Gets the underlying type of the specified <see cref="MemberInfo"/>.
        /// </summary>
        /// <param name="memberInfo">The member info.</param>
        /// <returns>
        /// The underlying type of the specified <see cref="MemberInfo"/>.
        /// </returns>
        public static Type GetUnderlyingType(
            this MemberInfo memberInfo)
        {
            if (memberInfo == null)
            {
                throw new ArgumentNullException(nameof(memberInfo));
            }

            switch (memberInfo.MemberType)
            {
                case MemberTypes.Event:
                    return ((EventInfo)memberInfo).EventHandlerType;
                case MemberTypes.Field:
                    return ((FieldInfo)memberInfo).FieldType;
                case MemberTypes.Method:
                    return ((MethodInfo)memberInfo).ReturnType;
                case MemberTypes.Property:
                    return ((PropertyInfo)memberInfo).PropertyType;
                default:
                    throw new ArgumentException("Input MemberInfo must be if type EventInfo, FieldInfo, MethodInfo, or PropertyInfo");
            }
        }

        private static IReadOnlyList<MemberInfo> GetMembersHavingRelationshipsAndOwners(
            this Type type,
            MemberRelationships memberRelationships,
            MemberOwners memberOwners)
        {
            var result = new List<MemberInfo>();

            if (memberOwners == MemberOwners.None)
            {
                // no-op; no members to add
            }
            else if (memberRelationships == MemberRelationships.None)
            {
                // no-op; no members to add
            }
            else
            {
                var baseBindingFlags = BindingFlags.Public | BindingFlags.NonPublic;

                if (memberOwners.HasFlag(MemberOwners.Instance))
                {
                    baseBindingFlags |= BindingFlags.Instance;
                }

                if (memberOwners.HasFlag(MemberOwners.Static))
                {
                    baseBindingFlags |= BindingFlags.Static;
                }

                if (memberRelationships.HasFlag(MemberRelationships.DeclaredInType))
                {
                    var declaredMembers = type.GetMembers(baseBindingFlags | BindingFlags.DeclaredOnly);

                    result.AddRange(declaredMembers);
                }

                if (memberRelationships.HasFlag(MemberRelationships.InheritedByType))
                {
                    // If we are also looking for members declared in ancestor types, then that search will
                    // return all inherited members along with any non-inherited members.
                    if (!memberRelationships.HasFlag(MemberRelationships.DeclaredInAncestorTypes))
                    {
                        var inheritedMembers = type
                            .GetMembers(baseBindingFlags | BindingFlags.FlattenHierarchy)
                            .Where(_ => _.DeclaringType != type)
                            .ToList();

                        result.AddRange(inheritedMembers);
                    }
                }

                if (memberRelationships.HasFlag(MemberRelationships.DeclaredInAncestorTypes))
                {
                    var ancestorTypes = type.GetInheritancePath();

                    foreach (var ancestorType in ancestorTypes)
                    {
                        var ancestorDeclaredMembers = ancestorType.GetMembers(baseBindingFlags | BindingFlags.DeclaredOnly);

                        result.AddRange(ancestorDeclaredMembers);
                    }
                }

                if (memberRelationships.HasFlag(MemberRelationships.DeclaredInImplementedInterfaceTypes))
                {
                    var interfaceTypes = type.GetInterfaces();

                    foreach (var interfaceType in interfaceTypes)
                    {
                        var interfaceMembers = interfaceType.GetMembers(baseBindingFlags | BindingFlags.DeclaredOnly);

                        result.AddRange(interfaceMembers);
                    }
                }
            }

            return result;
        }

        private static IReadOnlyList<MemberInfo> FilterMembersHavingMutability(
            this IReadOnlyList<MemberInfo> members,
            MemberMutability memberMutability)
        {
            IReadOnlyList<MemberInfo> result;

            if (memberMutability == MemberMutability.None)
            {
                // no-op; no members to add
                result = new List<MemberInfo>();
            }
            else if (memberMutability == MemberMutability.All)
            {
                // shortcut for performance
                result = members;
            }
            else
            {
                var filteredMembers = new List<MemberInfo>();

                foreach (var member in members)
                {
                    var applicable = (member.MemberType == MemberTypes.Field) ||
                                     (member.MemberType == MemberTypes.Property);

                    var includeMember = (memberMutability.HasFlag(MemberMutability.Applicable) && applicable) ||
                                        (memberMutability.HasFlag(MemberMutability.NotApplicable) && (!applicable));

                    if (applicable && (!includeMember))
                    {
                        bool isReadable, isWritable, isNotWritable, isNotReadable;

                        if (member is PropertyInfo property)
                        {
                            isReadable = property.IsReadableProperty();
                            isNotReadable = property.IsNotReadableProperty();
                            isWritable = property.IsWritableProperty();
                            isNotWritable = property.IsNotWritableProperty();
                        }
                        else
                        {
                            var field = (FieldInfo)member;

                            isReadable = true;
                            isNotReadable = false;
                            isWritable = field.IsWritableField();
                            isNotWritable = field.IsNotWritableField();
                        }

                        includeMember = (memberMutability.HasFlag(MemberMutability.Readable) && isReadable) ||
                                        (memberMutability.HasFlag(MemberMutability.Writable) && isWritable) ||
                                        (memberMutability.HasFlag(MemberMutability.NotWritable) && isNotWritable) ||
                                        (memberMutability.HasFlag(MemberMutability.NotReadable) && isNotReadable);
                    }

                    if (includeMember)
                    {
                        filteredMembers.Add(member);
                    }
                }

                result = filteredMembers;
            }

            return result;
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment)]
        private static IReadOnlyList<MemberInfo> FilterMembersHavingAccessModifiers(
            this IReadOnlyList<MemberInfo> members,
            MemberAccessModifiers memberAccessModifiers)
        {
            IReadOnlyList<MemberInfo> result;

            if (memberAccessModifiers == MemberAccessModifiers.None)
            {
                // no-op; no members to add
                result = new List<MemberInfo>();
            }
            else if (memberAccessModifiers == MemberAccessModifiers.All)
            {
                // shortcut for performance
                result = members;
            }
            else
            {
                var filteredMembers = new List<MemberInfo>();

                foreach (var member in members)
                {
                    var memberAccessModifier = member.GetAccessModifier();

                    AccessModifier? getMethodAccessModifier = null;

                    AccessModifier? setMethodAccessModifier = null;

                    if (member is PropertyInfo propertyInfo)
                    {
                        getMethodAccessModifier = propertyInfo.GetMethod?.GetAccessModifier();

                        setMethodAccessModifier = propertyInfo.SetMethod?.GetAccessModifier();
                    }

                    var includeMember = (memberAccessModifiers.HasFlag(MemberAccessModifiers.Private) && (memberAccessModifier == AccessModifier.Private)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PrivateProtected) && (memberAccessModifier == AccessModifier.PrivateProtected)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.Protected) && (memberAccessModifier == AccessModifier.Protected)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.ProtectedInternal) && (memberAccessModifier == AccessModifier.ProtectedInternal)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.Internal) && (memberAccessModifier == AccessModifier.Internal)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.Public) && (memberAccessModifier == AccessModifier.Public)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PrivateGet) && (getMethodAccessModifier == AccessModifier.Private)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PrivateProtectedGet) && (getMethodAccessModifier == AccessModifier.PrivateProtected)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.ProtectedGet) && (getMethodAccessModifier == AccessModifier.Protected)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.ProtectedInternalGet) && (getMethodAccessModifier == AccessModifier.ProtectedInternal)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.InternalGet) && (getMethodAccessModifier == AccessModifier.Internal)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PublicGet) && (getMethodAccessModifier == AccessModifier.Public)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PrivateSet) && (setMethodAccessModifier == AccessModifier.Private)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PrivateProtectedSet) && (setMethodAccessModifier == AccessModifier.PrivateProtected)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.ProtectedSet) && (setMethodAccessModifier == AccessModifier.Protected)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.ProtectedInternalSet) && (setMethodAccessModifier == AccessModifier.ProtectedInternal)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.InternalSet) && (setMethodAccessModifier == AccessModifier.Internal)) ||
                                        (memberAccessModifiers.HasFlag(MemberAccessModifiers.PublicSet) && (setMethodAccessModifier == AccessModifier.Public));

                    if (includeMember)
                    {
                        filteredMembers.Add(member);
                    }
                }

                result = filteredMembers;
            }

            return result;
        }

        private static IReadOnlyList<MemberInfo> FilterMembersHavingKinds(
            this IReadOnlyList<MemberInfo> members,
            MemberKinds memberKinds)
        {
            IReadOnlyList<MemberInfo> result;

            if (memberKinds == MemberKinds.None)
            {
                // no-op; no members to add
                result = new List<MemberInfo>();
            }
            else if (memberKinds == MemberKinds.All)
            {
                // shortcut for performance
                result = members;
            }
            else
            {
                var filteredMembers = new List<MemberInfo>();

                foreach (var member in members)
                {
                    var includeMember = (memberKinds.HasFlag(MemberKinds.Constructor) && (member.MemberType == MemberTypes.Constructor)) ||
                                        (memberKinds.HasFlag(MemberKinds.Event) && (member.MemberType == MemberTypes.Event)) ||
                                        (memberKinds.HasFlag(MemberKinds.Field) && (member.MemberType == MemberTypes.Field)) ||
                                        (memberKinds.HasFlag(MemberKinds.Method) && (member.MemberType == MemberTypes.Method)) ||
                                        (memberKinds.HasFlag(MemberKinds.Property) && (member.MemberType == MemberTypes.Property)) ||
                                        (memberKinds.HasFlag(MemberKinds.NestedType) && (member.MemberType == MemberTypes.NestedType));

                    if (includeMember)
                    {
                        filteredMembers.Add(member);
                    }
                }

                result = filteredMembers;
            }

            return result;
        }

        private static IReadOnlyList<MemberInfo> FilterMembersHavingAttributes(
            this IReadOnlyList<MemberInfo> members,
            MemberAttributes memberAttributes)
        {
            IReadOnlyList<MemberInfo> result;

            if (memberAttributes == MemberAttributes.None)
            {
                // no-op; no members to add
                result = new List<MemberInfo>();
            }
            else if (memberAttributes == MemberAttributes.All)
            {
                // shortcut for performance
                result = members;
            }
            else
            {
                var filteredMembers = new List<MemberInfo>();

                foreach (var member in members)
                {
                    var memberIsCompilerGenerated = member.IsCompilerGenerated();

                    var includeMember = (memberAttributes.HasFlag(MemberAttributes.CompilerGenerated) && memberIsCompilerGenerated) ||
                                        (memberAttributes.HasFlag(MemberAttributes.NotCompilerGenerated) && (!memberIsCompilerGenerated));

                    if (includeMember)
                    {
                        filteredMembers.Add(member);
                    }
                }

                result = filteredMembers;
            }

            return result;
        }

        private static IReadOnlyList<MemberInfo> OrderMembers(
            this IReadOnlyList<MemberInfo> members,
            Type type,
            OrderMembersBy orderMembersBy)
        {
            IReadOnlyList<MemberInfo> result;

            if (orderMembersBy == OrderMembersBy.None)
            {
                result = members;
            }
            else if (orderMembersBy == OrderMembersBy.MemberName)
            {
                result = members.OrderBy(_ => _.Name).ToList();
            }
            else if ((orderMembersBy == OrderMembersBy.DeclaringTypeDerivationPath) || (orderMembersBy == OrderMembersBy.DeclaringTypeDerivationPathThenByMemberName))
            {
                var typeToIndexMap = new Type[0]
                    .Concat(new[] { type })
                    .Concat(type.GetInheritancePath())
                    .Reverse()
                    .Select((t, i) => new { Type = t, Index = i })
                    .ToDictionary(_ => _.Type, _ => _.Index);

                var orderedMembers = members
                    .OrderBy(_ =>
                    {
                        if (_.DeclaringType == null)
                        {
                            throw new NotSupportedException(Invariant($"Found a {_.GetType().ToStringReadable()} member named {_.Name} whose {nameof(MemberInfo.DeclaringType)} is null, which is not supported.  Member's {nameof(object.ToString)} value is: {_.ToString()}"));
                        }

                        // if member's declaring type is not in inheritance path, then
                        // ordered before all other members.
                        var index = typeToIndexMap.ContainsKey(_.DeclaringType)
                            ? typeToIndexMap[_.DeclaringType]
                            : -1;

                        return index;
                    });

                if (orderMembersBy == OrderMembersBy.DeclaringTypeDerivationPathThenByMemberName)
                {
                    orderedMembers = orderedMembers.ThenBy(_ => _.Name);
                }

                result = orderedMembers.ToList();
            }
            else
            {
                throw new NotSupportedException(Invariant($"This {nameof(OrderMembersBy)} is not supported: {orderMembersBy}."));
            }

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this MemberInfo memberInfo)
        {
            AccessModifier result;

            if (memberInfo is FieldInfo fieldInfo)
            {
                result = fieldInfo.GetAccessModifier();
            }
            else if (memberInfo is PropertyInfo propertyInfo)
            {
                result = propertyInfo.GetAccessModifier();
            }
            else if (memberInfo is ConstructorInfo constructorInfo)
            {
                result = constructorInfo.GetAccessModifier();
            }
            else if (memberInfo is MethodInfo methodInfo)
            {
                result = methodInfo.GetAccessModifier();
            }
            else if (memberInfo is EventInfo eventInfo)
            {
                result = eventInfo.GetAccessModifier();
            }
            else if ((memberInfo is Type nestedType) && (nestedType.IsNested))
            {
                result = nestedType.GetAccessModifier();
            }
            else
            {
                throw new InvalidOperationException(Invariant($"This {nameof(MemberInfo)} type was not expected: {memberInfo.GetType().ToStringReadable()}."));
            }

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this Type type)
        {
            AccessModifier result;

            if (!type.IsNested)
            {
                throw new InvalidOperationException(Invariant($"Type must be a nested type: {type.ToStringReadable()}"));
            }

            if (type.IsNestedPrivate)
            {
                result = AccessModifier.Private;
            }
            else if (type.IsNestedFamANDAssem)
            {
                result = AccessModifier.PrivateProtected;
            }
            else if (type.IsNestedFamily)
            {
                result = AccessModifier.Protected;
            }
            else if (type.IsNestedFamORAssem)
            {
                result = AccessModifier.ProtectedInternal;
            }
            else if (type.IsNestedAssembly)
            {
                result = AccessModifier.Internal;
            }
            else if (type.IsNestedPublic)
            {
                result = AccessModifier.Public;
            }
            else
            {
                throw new InvalidOperationException(Invariant($"Could not determine the access modifier for nested type: {type}."));
            }

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this FieldInfo fieldInfo)
        {
            AccessModifier result;

            if (fieldInfo.IsPrivate)
            {
                result = AccessModifier.Private;
            }
            else if (fieldInfo.IsFamilyAndAssembly)
            {
                result = AccessModifier.PrivateProtected;
            }
            else if (fieldInfo.IsFamily)
            {
                result = AccessModifier.Protected;
            }
            else if (fieldInfo.IsFamilyOrAssembly)
            {
                result = AccessModifier.ProtectedInternal;
            }
            else if (fieldInfo.IsAssembly)
            {
                result = AccessModifier.Internal;
            }
            else if (fieldInfo.IsPublic)
            {
                result = AccessModifier.Public;
            }
            else
            {
                throw new InvalidOperationException(Invariant($"Could not determine the access modifier for method: {fieldInfo}."));
            }

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this PropertyInfo propertyInfo)
        {
            // see: https://stackoverflow.com/questions/2426134/detect-access-modifier-type-on-a-property-using-reflection
            var methods = new List<MethodInfo>(2);

            if (propertyInfo.SetMethod != null)
            {
                methods.Add(propertyInfo.SetMethod);
            }

            if (propertyInfo.GetMethod != null)
            {
                methods.Add(propertyInfo.GetMethod);
            }

            var result = methods.GetHighestAccessModifier();

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this ConstructorInfo constructorInfo)
        {
            AccessModifier result;

            if (constructorInfo.IsPrivate)
            {
                result = AccessModifier.Private;
            }
            else if (constructorInfo.IsFamilyAndAssembly)
            {
                result = AccessModifier.PrivateProtected;
            }
            else if (constructorInfo.IsFamily)
            {
                result = AccessModifier.Protected;
            }
            else if (constructorInfo.IsFamilyOrAssembly)
            {
                result = AccessModifier.ProtectedInternal;
            }
            else if (constructorInfo.IsAssembly)
            {
                result = AccessModifier.Internal;
            }
            else if (constructorInfo.IsPublic)
            {
                result = AccessModifier.Public;
            }
            else
            {
                throw new InvalidOperationException(Invariant($"Could not determine the access modifier for method: {constructorInfo}."));
            }

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this MethodInfo methodInfo)
        {
            AccessModifier result;

            if (methodInfo.IsPrivate)
            {
                result = AccessModifier.Private;
            }
            else if (methodInfo.IsFamilyAndAssembly)
            {
                result = AccessModifier.PrivateProtected;
            }
            else if (methodInfo.IsFamily)
            {
                result = AccessModifier.Protected;
            }
            else if (methodInfo.IsFamilyOrAssembly)
            {
                result = AccessModifier.ProtectedInternal;
            }
            else if (methodInfo.IsAssembly)
            {
                result = AccessModifier.Internal;
            }
            else if (methodInfo.IsPublic)
            {
                result = AccessModifier.Public;
            }
            else
            {
                throw new InvalidOperationException(Invariant($"Could not determine the access modifier for method: {methodInfo}."));
            }

            return result;
        }

        private static AccessModifier GetAccessModifier(
            this EventInfo eventInfo)
        {
            // see: https://stackoverflow.com/questions/28410297/eventinfo-access-modifiers
            var methods = new List<MethodInfo>(2);

            if (eventInfo.AddMethod != null)
            {
                methods.Add(eventInfo.AddMethod);
            }

            if (eventInfo.RemoveMethod != null)
            {
                methods.Add(eventInfo.RemoveMethod);
            }

            if (eventInfo.RaiseMethod != null)
            {
                methods.Add(eventInfo.RaiseMethod);
            }

            var result = methods.GetHighestAccessModifier();

            return result;
        }

        private static AccessModifier GetHighestAccessModifier(
            this IReadOnlyCollection<MethodInfo> methods)
        {
            var result = methods.Select(_ => _.GetAccessModifier()).Max();

            return result;
        }
    }
}