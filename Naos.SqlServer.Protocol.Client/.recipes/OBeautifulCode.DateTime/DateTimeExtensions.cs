// --------------------------------------------------------------------------------------------------------------------
// <copyright file="DateTimeExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.DateTime.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.DateTime.Recipes
{
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Text.RegularExpressions;
    using global::System;
    using OBeautifulCode.CodeAnalysis.Recipes;
    using static global::System.FormattableString;

    /// <summary>
    /// Extension methods on <see cref="DateTime"/>.
    /// </summary>
#if !OBeautifulCodeDateTimeSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.DateTime.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class DateTimeExtensions
    {
        private static readonly Regex SimplifyTimeZoneNameRegex = new Regex(@"\(.*?\)", RegexOptions.Compiled);

        /// <summary>
        /// Finds a specified day-of-week after a reference date.
        /// </summary>
        /// <param name="value">The reference date.</param>
        /// <param name="dayOfWeek">The next day-of-week to find.</param>
        /// <returns>
        /// Returns the specified day-of-week that falls after the reference date.
        /// </returns>
        public static System.DateTime Next(
            this DateTime value,
            DayOfWeek dayOfWeek)
        {
            var daysToAdd = (int)dayOfWeek - (int)value.DayOfWeek;
            if (value.DayOfWeek >= dayOfWeek)
            {
                daysToAdd += 7;
            }

            var result = value.AddDays(daysToAdd);

            return result;
        }

        /// <summary>
        /// Finds a specified day-of-week prior to a reference date.
        /// </summary>
        /// <param name="value">The reference date.</param>
        /// <param name="dayOfWeek">The previous day-of-week to find.</param>
        /// <returns>
        /// Returns the specified day-of-week that falls prior to the reference date.
        /// </returns>
        public static DateTime Previous(
            this DateTime value,
            DayOfWeek dayOfWeek)
        {
            var daysToAdd = (int)dayOfWeek - (int)value.DayOfWeek;
            if (value.DayOfWeek <= dayOfWeek)
            {
                daysToAdd -= 7;
            }

            var result = value.AddDays(daysToAdd);

            return result;
        }

        /// <summary>
        /// Converts the provided time into a UTC time.
        /// </summary>
        /// <remarks>
        /// If <paramref name="value"/> is <see cref="DateTimeKind.Unspecified"/>, then the method will
        /// simply change it to <see cref="DateTimeKind.Utc"/>, it will NOT be treated as a local time
        /// as is the case with <see cref="DateTime.ToUniversalTime"/>
        /// </remarks>
        /// <param name="value">The reference time.</param>
        /// <returns>
        /// The UTC time.
        /// </returns>
        public static DateTime ToUtc(
            this DateTime value)
        {
            DateTime result;

            if (value.Kind == DateTimeKind.Utc)
            {
                result = value;
            }
            else if (value.Kind == DateTimeKind.Unspecified)
            {
                result = DateTime.SpecifyKind(value, DateTimeKind.Utc);
            }
            else
            {
                result = value.ToUniversalTime();
            }

            return result;
        }

        /// <summary>
        /// Converts the provided time into a UTC time.
        /// </summary>
        /// <param name="value">The reference time.</param>
        /// <remarks>
        /// If <paramref name="value"/> is <see cref="DateTimeKind.Unspecified"/>, then the method will
        /// simply change it to <see cref="DateTimeKind.Utc"/>, it will NOT be treated as a local time
        /// as is the case with <see cref="DateTime.ToUniversalTime"/>
        /// </remarks>
        /// <returns>
        /// The UTC time.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value"/> is null.</exception>
        /// <exception cref="NotSupportedException"><paramref name="value"/> <see cref="DateTimeKind"/> is not supported.</exception>
        public static DateTime ToUtc(
            this DateTime? value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            var result = ((DateTime)value).ToUtc();

            return result;
        }

        /// <summary>
        /// Converts the provided time into an Unspecified time.
        /// </summary>
        /// <param name="value">The reference time.</param>
        /// <returns>
        /// The Unspecified time.
        /// </returns>
        public static DateTime ToUnspecified(
            this DateTime value)
        {
            var result = value.Kind == DateTimeKind.Unspecified
                ? value
                : DateTime.SpecifyKind(value, DateTimeKind.Unspecified);

            return result;
        }

        /// <summary>
        /// Converts the specified time into a Unspecified time.
        /// </summary>
        /// <param name="value">The reference time.</param>
        /// <returns>
        /// The Unspecified time.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value"/> is null.</exception>
        public static DateTime ToUnspecified(
            this DateTime? value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            var result = ((DateTime)value).ToUnspecified();

            return result;
        }

        /// <summary>
        /// Converts the specified time into a specified timezone.
        /// </summary>
        /// <param name="value">The reference time.</param>
        /// <param name="timeZoneInfo">The time zone to convert to.</param>
        /// <returns>
        /// The Specific timezone time.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="timeZoneInfo"/> is null.</exception>
        public static DateTimeOffset ToSpecificTimeZone(
            this DateTime value,
            TimeZoneInfo timeZoneInfo)
        {
            if (timeZoneInfo == null)
            {
                throw new ArgumentNullException(nameof(timeZoneInfo));
            }

            DateTimeOffset newTime = TimeZoneInfo.ConvertTime(
                value,
                timeZoneInfo);

            var result = newTime.DateTime;

            return result;
        }

        /// <summary>
        /// Converts the specified time into a specified timezone.
        /// </summary>
        /// <param name="value">The reference time.</param>
        /// <param name="timeZoneInfo">The timezone to convert to.</param>
        /// <returns>
        /// The Specific timezone time.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="timeZoneInfo"/> is null.</exception>
        public static DateTimeOffset ToSpecificTimeZone(
            this DateTime? value,
            TimeZoneInfo timeZoneInfo)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            var result = ((DateTime)value).ToSpecificTimeZone(timeZoneInfo);

            return result;
        }

        /// <summary>
        /// Converts the specified time into a friendly string in the specified time zone.
        /// </summary>
        /// <param name="utcValue">The UTC time to stringify.</param>
        /// <param name="timeZoneInfo">OPTIONAL timezone for the string.  DEFAULT is UTC.</param>
        /// <returns>
        /// A friendly string representation of the specified time in the specified time zone.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="utcValue"/> is null.</exception>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "Prefer lower case.")]
        public static string ToStringPretty(
            this DateTime utcValue,
            TimeZoneInfo timeZoneInfo = null)
        {
            if (utcValue.Kind != DateTimeKind.Utc)
            {
                throw new ArgumentException(Invariant($"{utcValue} is not a UTC date/time."));
            }

            var displayTime = utcValue;

            var timeZoneName = "gmt";

            if (timeZoneInfo != null)
            {
                displayTime = displayTime.ToSpecificTimeZone(timeZoneInfo).DateTime;

                timeZoneName = SimplifyTimeZoneNameRegex.Replace(timeZoneInfo.DisplayName, string.Empty).Trim().ToLowerInvariant();
            }

            var formatString = "dddd, MMMM d, yyyy 'at' h:mm tt";

            var result = Invariant($"{displayTime.ToString(formatString, CultureInfo.InvariantCulture)} ({timeZoneName})");

            return result;
        }

        /// <summary>
        /// Rolls the time backwards until it's an even minute version of the provided <see cref="DateTime" /> (zero seconds, milliseconds, etc.).
        /// </summary>
        /// <param name="dateTime">The date time to use as a base.</param>
        /// <returns>The reduced version of the provided <see cref="DateTime" />.</returns>
        public static DateTime RewindToEvenMinute(
            this DateTime dateTime)
        {
            var result = new DateTime(
                dateTime.Year,
                dateTime.Month,
                dateTime.Day,
                dateTime.Hour,
                dateTime.Minute,
                0,
                dateTime.Kind);

            return result;
        }

        /// <summary>
        /// Rolls the time backwards to the provided <see cref="DateTime" /> to the next matching provided hour and minute.
        /// </summary>
        /// <param name="dateTime">The date time to use as a base.</param>
        /// <param name="hour">The hour to advance to.</param>
        /// <param name="minute">The minute to advance to.</param>
        /// <returns>The advanced <see cref="DateTime" />.</returns>
        public static DateTime RewindToNextMatchingHourAndMinute(
            this DateTime dateTime, int hour, int minute)
        {
            if (hour < 0)
            {
                throw new ArgumentException(Invariant($"The hour of the day cannot be less than 0.  It was {hour}"));
            }

            if (hour > 23)
            {
                throw new ArgumentException(Invariant($"The hour of the day cannot be more than 23.  It was {hour}"));
            }

            if (minute < 0)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be less than 0.  It was {minute}"));
            }

            if (minute > 59)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be more than 59.  It was {minute}"));
            }


            var result = dateTime;
            while (result.Hour != hour || result.Minute != minute || result == dateTime)
            {
                result = result.Subtract(TimeSpan.FromMinutes(1));
            }

            return result;
        }

        /// <summary>
        /// Rolls the time backwards to the provided <see cref="DateTime" /> to the next matching provided minute.
        /// </summary>
        /// <param name="dateTime">The date time to use as a base.</param>
        /// <param name="minute">The minute to advance to.</param>
        /// <returns>The advanced <see cref="DateTime" />.</returns>
        public static DateTime RewindToNextMatchingMinute(
            this DateTime dateTime, int minute)
        {
            if (minute < 0)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be less than 0.  It was {minute}"));
            }

            if (minute > 59)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be more than 59.  It was {minute}"));
            }

            var result = dateTime;
            while (result.Minute != minute || result == dateTime)
            {
                result = result.Subtract(TimeSpan.FromMinutes(1));
            }

            return result;
        }

        /// <summary>
        /// Advances to the provided <see cref="DateTime" /> to the next matching provided hour and minute.
        /// </summary>
        /// <param name="dateTime">The date time to use as a base.</param>
        /// <param name="hour">The hour to advance to.</param>
        /// <param name="minute">The minute to advance to.</param>
        /// <returns>The advanced <see cref="DateTime" />.</returns>
        public static DateTime AdvanceToNextMatchingHourAndMinute(
            this DateTime dateTime, int hour, int minute)
        {
            if (hour < 0)
            {
                throw new ArgumentException(Invariant($"The hour of the day cannot be less than 0.  It was {hour}"));
            }

            if (hour > 23)
            {
                throw new ArgumentException(Invariant($"The hour of the day cannot be more than 23.  It was {hour}"));
            }

            if (minute < 0)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be less than 0.  It was {minute}"));
            }

            if (minute > 59)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be more than 59.  It was {minute}"));
            }

            var result = dateTime;
            while (result.Hour != hour || result.Minute != minute || result == dateTime)
            {
                result = result.Add(TimeSpan.FromMinutes(1));
            }

            return result;
        }

        /// <summary>
        /// Advances to the provided <see cref="DateTime" /> to the next matching provided minute.
        /// </summary>
        /// <param name="dateTime">The date time to use as a base.</param>
        /// <param name="minute">The minute to advance to.</param>
        /// <returns>The advanced <see cref="DateTime" />.</returns>
        public static DateTime AdvanceToNextMatchingMinute(
            this DateTime dateTime, int minute)
        {
            if (minute < 0)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be less than 0.  It was {minute}"));
            }

            if (minute > 59)
            {
                throw new ArgumentException(Invariant($"The minute of the hour cannot be more than 59.  It was {minute}"));
            }

            var result = dateTime;
            while (result.Minute != minute || result == dateTime)
            {
                result = result.Add(TimeSpan.FromMinutes(1));
            }

            return result;
        }
    }
}
