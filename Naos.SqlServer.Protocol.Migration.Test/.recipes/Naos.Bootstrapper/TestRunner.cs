// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TestRunner.cs" company="Naos Project">
//   Copyright (c) Naos Project 2019. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in 'Naos.Bootstrapper.Recipes.Core.Test' source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Naos.Bootstrapper
{
    using System;
    using System.Threading;
    using OBeautifulCode.Assertion.Recipes;
    using OBeautifulCode.Reflection.Recipes;
    using Xunit.Runners;

    using static System.FormattableString;

    /// <summary>
    /// Runner for xUnit tests.
    /// </summary>
    #if NaosBootstrapper
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly", Justification = "For this item the implementation is as intended.")]
    #else
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Naos.Bootstrapper.Recipes.Core.Test", "See package version.")]
    #endif
    public class TestRunner : IDisposable
    {
        // We use consoleLock because messages can arrive in parallel, so we want to make sure we get
        // consistent console output.
        private readonly object announcementLock = new object();

        private readonly Action<string> announcer;

        // Use an event to know when we're done.
        private readonly ManualResetEvent finished = new ManualResetEvent(false);

        // Start out assuming success; will be updated in failure event method.
        private bool seenFailures = false;

        /// <summary>
        /// Initializes a new instance of the <see cref="TestRunner" /> class.
        /// </summary>
        /// <param name="announcer">The announcer to get details about any failures.</param>
        public TestRunner(
            Action<string> announcer)
        {
            this.announcer = announcer;
        }

        /// <summary>
        /// Runs the type of all tests found (and not skipped) in the provided type.
        /// </summary>
        /// <param name="typeToRunTestsFrom">The type to run tests from.</param>
        /// <returns>A value indicating whether or not the run was successful.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xunit", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "ToRun", Justification = "Spelling/name is correct.")]
        public bool RunAllTestsInTypeUsingXunit(Type typeToRunTestsFrom)
        {
            new { typeToRunTestsFrom }.Must().NotBeNull();
            var typeNameToRunTestsFrom = typeToRunTestsFrom.FullName;

            var testAssemblyPath = typeToRunTestsFrom.Assembly.GetCodeBaseAsPathInsteadOfUri();
            using (var runner = AssemblyRunner.WithAppDomain(testAssemblyPath))
            {
                runner.OnDiscoveryComplete = this.OnDiscoveryComplete;
                runner.OnTestOutput = this.OnTestOutput;
                runner.OnTestPassed = this.OnTestPassed;
                runner.OnTestFailed = this.OnTestFailed;
                runner.OnTestSkipped = this.OnTestSkipped;
                runner.OnExecutionComplete = this.OnExecutionComplete;

                lock (this.announcementLock)
                {
                    this.announcer(" * Discovering tests in type.");
                }

                runner.Start(typeNameToRunTestsFrom);

                this.finished.WaitOne();
                this.finished.Dispose();

                return !this.seenFailures;
            }
        }

        private void OnDiscoveryComplete(DiscoveryCompleteInfo info)
        {
            lock (this.announcementLock)
            {
                this.announcer(Invariant($" * Running {info.TestCasesToRun} of {info.TestCasesDiscovered} tests."));
            }
        }

        private void OnTestOutput(TestOutputInfo info)
        {
            lock (this.announcementLock)
            {
                this.announcer(Invariant($"   - {info.TestDisplayName}: {info.Output}"));
            }
        }

        private void OnTestPassed(TestPassedInfo info)
        {
            lock (this.announcementLock)
            {
                this.announcer(Invariant($"   ^ [PASS] {info.TestDisplayName}: Passed."));
            }
        }

        private void OnTestFailed(TestFailedInfo info)
        {
            lock (this.announcementLock)
            {
                this.announcer(Invariant($"   ! [FAIL] {info.TestDisplayName}: {info.ExceptionMessage}."));
                if (info.ExceptionStackTrace != null)
                {
                    this.announcer(info.ExceptionStackTrace);
                }
            }

            this.seenFailures = true;
        }

        private void OnTestSkipped(TestSkippedInfo info)
        {
            lock (this.announcementLock)
            {
                this.announcer(Invariant($"   # [SKIP] {info.TestDisplayName}: {info.SkipReason}"));
            }
        }

        private void OnExecutionComplete(ExecutionCompleteInfo info)
        {
            lock (this.announcementLock)
            {
                this.announcer(Invariant($" * Finished: {info.TotalTests} tests in {Math.Round(info.ExecutionTime, 3)}s ({info.TestsFailed} failed, {info.TestsSkipped} skipped)."));
            }

            this.finished.Set();
        }

        /// <inheritdoc />
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1816:CallGCSuppressFinalizeCorrectly", Justification = "For this item the implementation is as intended.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly", Justification = "For this item the implementation is as intended.")]
        public void Dispose()
        {
            this.finished.Dispose();
        }
    }
}